{
   on pattern() 
      delay # 
      parallel {
         post (POS 0);
         post (TIME 0);
	 post (PS 12 0);
         post (LAYER 0);
	 post (WORD 0 0 "H");
	 post (WORD 0 1 "O");
	 post (WORD 0 2 "R");
	 post (WORD 0 3 "S");
	 post (WORD 0 4 "E");
	 post (WORD 0 5 "S");
	 post (WORD 0 6 " ");
	 post (WORD 0 7 " ");
	 post (WORD 0 8 " ");
	 post (WORD 0 9 " ");
	 post (WORD 0 10 " ");
	 post (WORD 0 11 " ");
	 post (WORD 0 12 " ");

	 post (LS 0 1);
	 post (LAYER 1);
	 post (WORD 1 0 "C");
	 post (WORD 1 1 "O");
	 post (WORD 1 2 "W");
	 post (WORD 1 3 "S");
	 post (WORD 1 4 " ");
	 post (WORD 1 5 " ");
	 post (WORD 1 6 " ");
	 post (WORD 1 7 " ");
	 post (WORD 1 8 " ");
	 post (WORD 1 9 " ");
	 post (WORD 1 10 " ");
	 post (WORD 1 11 " ");
	 post (WORD 1 12 " ");

	 post (LP 0 0 3); <at time 0 layer 0 is at position 3>
	 post (LP 0 1 12); <at time 0 layer 1 is at position 12>
      }

   <generate all the positions and position-successor relations>
   on pattern((POS p)) parallel {
      delay #     
      if (equal p 12) {
        pass;
        let q (sum p 1)
	   parallel {
             post (POS q);
	     post (PS p q);
	   }
      }
   }
   < generate all the times and time-successor relations >
   on pattern((TIME t)) parallel {
      delay #     
      if (equal t 100) {
        pass;
        let u (sum t 1)
	   parallel {
             post (TIME u);
	     post (TS t u);
	     let d (choose (independent_bool 0.5) )
	       let p (choose (independent_uint 13) )
	          post (CLICK t p d);
	   }
      }
   }

   <
   on pattern((TIME t)(POS p)) parallel {
       delay #
       post (TOPN t p 0 " ");
   }
   on pattern((TOPN t p n c) (TLPV t l p v
>
}
<
  on pattern()	
    parallel {	
      post (S 0	1);
      post (C 0 0);	
    }
  on pattern((S x y))
    delay #
      if (equal y 100) {
        pass;
	let z (sum y 1)
	  post (S y z);
      }
  on pattern((C x 0)(S x y)) 
    delay #0
       post (C y 1);
  on pattern((C x 1)(S x y)) 
    delay #0
       post (C y 0);
  on pattern((C a b))
    delay #0
       post (maketuple COUT (concat "(C POS_" (tostring a) " *CHAR_" (tostring b) ")\n"));
  on pattern((S a b))
    delay #0
       post (maketuple COUT (concat "(S POS_" (tostring a) " *POS_" (tostring b) ")\n"));
>